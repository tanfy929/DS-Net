

from torch.nn import Module, Sequential

# import torch
# import numpy as np

from abc import ABC, abstractmethod

from typing import Tuple

__all__ = ["MyModule"]


class MyModule(Module, ABC):

    def __init__(self):
        r"""
        Abstract base class for all equivariant modules.

        An :class:`~EquivariantModule` is a subclass of :class:`torch.nn.Module`.
        It follows that any subclass of :class:`~EquivariantModule` needs to implement the
        :meth:`~e2cnn.nn.EquivariantModule.forward` method.
        With respect to a general :class:`torch.nn.Module`, an *equivariant module* implements a *typed* function as
        both its input and its output are associated with specific :class:`~e2cnn.nn.FieldType` s.
        Therefore, usually, the inputs and the outputs of an *equivariant module* are not just instances of
        :class:`torch.Tensor` but :class:`~e2cnn.nn.GeometricTensor` s.

        As a subclass of :class:`torch.nn.Module`, it supports most of the commonly used methods (e.g.
        :meth:`torch.nn.Module.to`, :meth:`torch.nn.Module.cuda`, :meth:`torch.nn.Module.train` or
        :meth:`torch.nn.Module.eval`)

        Many equivariant modules implement a :meth:`~e2cnn.nn.EquivariantModule.export` method which converts the module
        to *eval* mode and returns a pure PyTorch implementation of it.
        This can be used after training to efficiently deploy the model without, for instance, the overhead of the
        automatic type checking performed by all the modules in this library.

        .. warning ::

            Not all modules implement this feature yet.
            If the :meth:`~e2cnn.nn.EquivariantModule.export` method is called in a module which does not implement it
            yet, a :class:`NotImplementedError` is raised.
            Check the documentation of each individual module to understand if the method is implemented.

        Attributes:
            ~.in_type (FieldType): type of the :class:`~e2cnn.nn.GeometricTensor` expected as input
            ~.out_type (FieldType): type of the :class:`~e2cnn.nn.GeometricTensor` returned as output

        """
        super(MyModule, self).__init__()

        # FieldType: type of the :class:`~e2cnn.nn.GeometricTensor` expected as input
        #        self.in_type = None
        self.ft_BN = False

        # FieldType: type of the :class:`~e2cnn.nn.GeometricTensor` returned as output

    #        self.out_type = None

    @abstractmethod
    def forward(self, *input):
        pass

    #    @abstractmethod
    #    def evaluate_output_shape(self, input_shape: Tuple[int, ...]) -> Tuple[int, ...]:
    #        r"""
    #        Compute the shape the output tensor which would be generated by this module when a tensor with shape
    #        ``input_shape`` is provided as input.
    #
    #        Args:
    #            input_shape (tuple): shape of the input tensor
    #
    #        Returns:
    #            shape of the output tensor
    #
    #        """
    #        pass

    def FT_BN(self, mode=False):
        if mode:
            self.ft_BN = True
        #            print('GetHere')
        else:
            self.ft_BN = False
        #            print('GetHere')

        for module in self.children():
            #            print(module)
            if hasattr(module, 'Pre_BN'):
                #                print(module)
                module.FT_BN(mode)
        return self


